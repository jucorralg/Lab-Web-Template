{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"conclusion/","title":"Related Sessions at Cisco Live","text":""},{"location":"conclusion/#related-sessions-at-cisco-live","title":"Related Sessions at Cisco Live","text":"<ul> <li>BRKXXX-1111 My friend's breakout session</li> </ul>"},{"location":"lab0_testing/","title":"Lab 0 - testing md file","text":""},{"location":"lab0_testing/#lab-0-proactive-outbound-reach-campaign-manager","title":"Lab 0: Proactive Outbound Reach (Campaign Manager)","text":""},{"location":"lab0_testing/#objective","title":"Objective:","text":"<p>Configure and execute a proactive outbound debt notification using Webex Contact Center Native Campaign Manager.</p>"},{"location":"lab0_testing/#lab-summary","title":"Lab Summary:","text":"<p>In this lab, participants implement the outbound entry point of the use case. A proactive voice campaign is created to notify customers when a debt maturity date is approaching. </p> <p>Participants will: - Create a Debt Collection DB to be used - Configure an outbound voice campaign using\u00a0Native Campaign Manager. - Define campaign parameters and upload a contact list derived from the\u00a0Customer Debt DB. - Configure retry logic for customers who do not answer the initial reminder. - Associate the campaign with a specific Webex Contact Center flow designed for debt handling.</p>"},{"location":"lab0_testing/#outcome","title":"Outcome:","text":"<p>At the end of this lab, a proactive outbound call is successfully triggered and routed into the AI Agent flow, forming the entry point for the debt collection journey.</p>"},{"location":"lab1_bruno/","title":"Lab 1 - Using Postman to interact with CJDS.","text":""},{"location":"lab1_bruno/#using-brunopostman-to-interact-with-cjds","title":"Using Bruno/Postman to interact with CJDS","text":"<p>CJDS is an API-first service, meaning that most of the configuration will be done via API using tools such as Postman and Bruno. For this lab, we prefer using Bruno as it doesn't require an account for you to import an API collection later in the lab. Also, all the instructions (including screenshots and gifs) were done using Bruno. </p> Warning <p>Bruno and Postman clients are installed in the laptop, do not use any web versions. </p> WxCC Connector GIF <p>In this lab tenant, the Webex Contact Center connector for CJDS has been enabled. You DO NOT need to do it and your admin account doesn't have access. However, here's a video showing you how to do it for your learning: </p> <p></p>"},{"location":"lab1_bruno/#lab-11-create-a-webex-app-integration","title":"Lab 1.1 Create a Webex App Integration","text":"Instructions <ol> <li>Navigate to the Webex for Developers website. </li> <li>Login via the button on the top right and use your admin credentials. </li> <li>Once logged in navigate to \u201cMy Webex Apps\u201d under your login avatar at the top right and then select \u201cCreate a New App\u201d. </li> <li>Create a new integration app by clicking \"Create an Integration\"</li> <li>Fill out the new integration with these parameters:<ul> <li>Integration Name : JDS with Bruno</li> <li>Icon: pick your favorite</li> <li>App Hub Description: JDS with Bruno  </li> <li>Redirect URL(s): https://oauth.pstmn.io/v1/callback</li> <li>Scopes: Check the top three check boxes.     <pre><code>-cjp:config\n-cjp:config_write\n-cjp:config_read\n</code></pre></li> <li>Click Add Integration</li> </ul> Webex App Integration GIF </li> <li>Copy and save the Client ID and the Client Secret. </li> </ol>"},{"location":"lab1_bruno/#lab-12-configure-postmanbruno-to-send-apis-to-cjds","title":"Lab 1.2 Configure Postman/Bruno to send APIs to CJDS","text":"<p>Note</p> <p>You can find the full API documentation here</p> Instructions <p>Open Bruno and you should see the collection that was exported during the Getting Started section of the lab. Now let\u2019s change some of the collection settings:</p> <ol> <li>Click on the collection name \"Wx1 JDS Collection\" in the left panel and you will see the settings.  </li> <li> <p>Click on the Variables tab and update the following fields, set the Initial and Current value to the same values described below:  </p> <ul> <li>client_id \u2013 Set this to the Client ID for the Webex App you added earlier.  </li> <li>client_secret \u2013 Set this to the Client Secret for the Webex App you added earlier.</li> <li>org_id \u2013 This is an optional setting. </li> <li> <p>workspaceId \u2013 This is the ID for your lab tenant: 67e2e90ec4b84e752570056c</p> Bruno Authentication Variables IMG <p></p> <p></p> </li> </ul> </li> <li> <p>Now click on the Authorization tab to the right of the Variables tab and scroll to the bottom of the screen.</p> </li> <li> <p>Click on the \u201cGet Access Token\u201d button.</p> Get New Access Token IMG <p></p> <p></p> </li> <li> <p>A Webex login window will pop up, enter the admin sandbox credentials that you used to create the Webex App integration. </p> Bruno Permission Request IMG <p></p> <p></p> </li> <li> <p>Bruno will intercept the bearer Access Token and a Refresh Token from the CallbackURL you setup in the app integration, now you can use the token to send API calls to CJDS. Bruno will also manage the Access Token expiration by using the Refresh Token on your behalf.</p> Bruno Token IMG <p></p> </li> </ol>"},{"location":"lab1_bruno/#lab-13-sending-api-calls-to-cjds-using-bruno","title":"Lab 1.3 Sending API Calls to CJDS using Bruno","text":"Instructions <p>Let\u2019s test one of the API calls from the Bruno collection to confirm it works.</p> <ol> <li> <p>Under the Wx1 JDS Collection on the left navigation pane, Click the green \u201cGET\u201d named \u201cGet History Stream\u201d. This will open the REST call in a tab on the right, Send the request by clicking the arrow icon and you should see in the response tab recent JDS events.</p> GET History IMG <p></p> <p></p> </li> <li> <p>If the previous step is successful, it confirms that the Bruno app is correctly configured to interact with CDJS. Now, let's update other variables in the Wx1 JDS Collection: </p> <ul> <li>The variables firstName, lastName and address information can be random. </li> <li>The phoneNumber and identity has to match the PSTN number you will use to call, make sure the + is included. </li> <li>The accountNumber is a random value you assign, it needs to be 8 digits long. In order to avoid duplicates in the lab, don't use account numbers such as: 12345678, 11111111, 87654321, etc.</li> </ul> Update Collection Variables <p></p> <p></p> </li> <li> <p>Open the POST call named \u201cJDS PageVisit\u201d located on the left side under the Wx1 JDS Collection. Edit the Body of the call and change the identity to a fake email account, such as test-PODXX@test.com. Send the request and you should get a response stating that the data was \u201cAccepted for processing\u201d.</p> JDS PageVisit POST IMG <p></p> <p></p> </li> <li> <p>Click on the \u201cGet History Stream by identity\u201d call and replace the identity with the fake email from the previous step. Send the request and you should see your new event in the JDS tape!</p> GET History by Identity IMG <p></p> <p></p> </li> </ol> <p>Congratulations! You have completed this section of the lab.</p>"},{"location":"lab2_query_JDS/","title":"Lab 2 - CJDS Identity Management, Progressive Profiles and Actions.","text":""},{"location":"lab2_query_JDS/#jds-identity-management-and-progressive-profiles","title":"JDS Identity Management and Progressive Profiles.","text":""},{"location":"lab2_query_JDS/#lab-21-identity-management","title":"Lab 2.1 Identity Management","text":"Instructions <ol> <li> <p>In the previous lab, we sent an event to JDS using a fake email as the identity. However, we did not create this identity in JDS ahead of time. Let's check what is the current view of this \"person\" within JDS. Go to the \"Person Details\" request, enter the fake email you used on the identities section and send the request:</p> Empty Identity IMG <p></p> <p></p> </li> <li> <p>In the response, you can see that there's no name, phone or customer id. JDS automatically created this profile when you sent the previous event, let's use the merge API to add more details to this person profile. Select the Merge Identity API in Bruno and fill out the fields in the body section of the request. Send the request to push this data to the existing identity: </p> Merge Identity IMG <p></p> <p></p> </li> <li> <p>In the response, you will see how the aliases include the fake email and the phone number setup in the Collection variables. Now click on the JDS Purchase POST request and send the event to the JDS tape. </p> Purchase Post IMG <p></p> <p></p> </li> <li> <p>Click on the \u201cGet History Stream by identity\u201d call and replace the identity with the phone number variable. Send the request and you should see the JDS events matching both the email and phone number coming up in the history. </p> Note <p>There are other ways to create and edit Identities in JDS. You can create identities in bulk from Control Hub or create person profiles programmatically by using the Create Person API. </p> </li> </ol>"},{"location":"lab2_query_JDS/#lab-22-adding-jds-to-the-navigation-page-of-the-agent-desktop","title":"Lab 2.2 Adding JDS to the Navigation page of the Agent Desktop.","text":"<p>The JDS widget is now included in the Default Desktop Layout, but for this lab we would like to see the JDS widget without an active interaction. In order to do this, you have to add the JDS widget to the navigation pane section of the Desktop Layout. </p> Instructions <ol> <li>In Control Hub, go to the Desktop Layouts menu. Click the option \"Create Desktop Layout\", a menu to configure your template will come up, enter the name POD-XX_Layout and select the Team associated to your POD number. </li> <li> <p>Download the JDS_LAB_Layout and open it using Notepad++. Find the Navigation section and replace the existing data with the following widget information: </p><pre><code>{\n  \"nav\": {\n    \"label\": \"Journey Data Services\",\n    \"icon\": \"accessories\",\n    \"iconType\": \"momentum\",\n    \"navigateTo\": \"customerJourneyWidget\",\n    \"align\": \"top\"\n  },\n  \"page\": {\n    \"id\": \"customerJourneyWidget\",\n    \"widgets\": {\n      \"right\": {\n        \"comp\": \"customer-journey-widget\",\n        \"script\": \"https://journey-widget.webex.com\",\n        \"attributes\": {\n          \"show-alias-icon\": \"true\",\n          \"condensed-view\": \"true\",\n          \"enable-user-search\": \"true\"\n        },\n        \"properties\": {\n          \"bearerToken\": \"$STORE.auth.accessToken\",\n          \"organizationId\": \"$STORE.agent.orgId\",\n          \"dataCenter\": \"$STORE.app.datacenter\"\n        },\n        \"wrapper\": {\n          \"title\": \"Customer Journey Widget\",\n          \"maximizeAreaName\": \"app-maximize-area\"\n        }\n      }\n    },\n    \"layout\": {\n      \"areas\": [\n        [\n          \"right\"\n        ]\n      ],\n      \"size\": {\n        \"cols\": [\n          1\n        ],\n        \"rows\": [\n          1\n        ]\n      }\n    }\n  }\n}\n</code></pre> Use the following picture to confirm you modified the JSON file correctly:<p></p> JDS Navigation Section <p></p> <p></p> </li> <li> <p>Save the changes in the file and select the option \"Replace file\" back in the Desktop Layout menu. Select the modified file and then click the \"Create\" option. </p> </li> <li>In an incognito window, navigate to the WxCC Agent Desktop and use your Agent credentials provided by a lab proctor to login.</li> <li>Set your \"Station Credentials\" to Desktop telephony option.</li> <li>You should now see the JDS widget in the navigation page, select it and do a search for your identity. </li> <li>The JDS widget should show the events you previously sent and the default profile template metrics in the JDS widget header. </li> </ol> <p>Now let's create your own Profile Template to modify the metrics. </p>"},{"location":"lab2_query_JDS/#lab-23-profile-templates","title":"Lab 2.3 Profile Templates","text":"<p>Administrators can use profile templates to customize the data presented to the Agent in the JDS widget header, in this lab section you will create a profile that displays the amount of Page Visit events in the last 120 minutes.              </p> <p></p> Instructions <ol> <li>Using Bruno, select the API called \"Create Profile Template\". You can add multiple metrics to a profile, modify the first entry in the API JSON to match the following:  <pre><code>\"name\": \"PageVisits_PODXX\",\n\"attributes\": [\n    {\n        \"version\": \"1.0\",\n        \"event\": \"task:new\",\n        \"metaDataType\": \"string\",\n        \"metaData\": \"channelType\",\n        \"limit\": 100,\n        \"displayName\": \"Page Visits within 2 hours\",\n        \"lookBackDurationType\": \"minutes\",\n        \"lookBackPeriod\": 120,\n        \"aggregationMode\": \"Count\",\n        \"rules\": {\n            \"logic\": \"SINGLE\",\n            \"condition\": \"task:new,channelType,string,Value EQ Website\"\n        },\n        \"widgetAttributes\": {\n            \"type\": \"table\"\n        },\n        \"verbose\": false\n    },\n</code></pre></li> <li>Confirm that the other metrics for \"Contacts within 10 days\" and \"Contacts within 24 hours\" are included in the JSON body. </li> <li>Send the POST API call to create the profile.</li> <li>Select the GET Profiles API and run it to confirm you see both the default profile template and your new profile template. Copy the id of your profile template. </li> <li>Open the Desktop Layout you previously modified, you need to configure your template ID into it so that the JDS widget know what information to show. </li> <li>In the Desktop Layout, you need to modify the JDS widget that comes up when calls or digital tasks are active, and the JDS widget in the navigation pane. Add the line \"template-id\": \"\" to the attributes section, Here's an example: Navigation pane: <pre><code>\"page\": {\n        \"id\": \"customerJourneyWidget\",\n        \"widgets\": {\n          \"right\": {\n            \"comp\": \"customer-journey-widget\",\n            \"script\": \"https://journey-widget.webex.com\",\n            \"attributes\": {\n              \"condensed-view\": \"true\",\n              \"show-alias-icon\": \"true\",\n              \"template-id\": \"68d627030750c0634702a46e\"\n            },\n</code></pre> Widget for Active Calls: <pre><code>{\n        \"comp\": \"md-tab-panel\",\n        \"attributes\": {\n          \"slot\": \"panel\",\n          \"class\": \"widget-pane\"\n        },\n        \"children\": [\n          {\n            \"comp\": \"customer-journey-widget\",\n            \"script\": \"https://journey-widget.webex.com\",\n            \"attributes\": {\n              \"show-alias-icon\": \"true\",\n              \"condensed-view\": \"true\",\n              \"template-id\": \"68d627030750c0634702a46e\"\n            }\n</code></pre></li> <li>Save and upload the new desktop layout file. </li> <li>Reload the agent desktop and confirm that the new profile template value is coming up. </li> </ol> <p>Congratulations! You have completed this section of the lab.</p>"},{"location":"lab3_injecting_JDS_event/","title":"Lab 3 - IVR flow integration with CJDS","text":""},{"location":"lab3_injecting_JDS_event/#wxcc-flow-designer-integration-with-cjds","title":"WxCC Flow Designer Integration with CJDS","text":""},{"location":"lab3_injecting_JDS_event/#lab-31-query-jds-in-an-ivr-flow-for-greeting-customization","title":"Lab 3.1 Query JDS in an IVR flow for greeting customization.","text":"Instructions <ol> <li>Download the IVR flow JDS_LAB_Flow_PODXX. Open the json file using notepad++, find the name section and replace the XX within the name to match your POD number, example: \"name\":\"JDS_LAB_Flow_POD91\". </li> <li>Login to Webex Control Hub with your administrator account. Select the Contact Center option on the Services section in the left pane. </li> <li>Go to \u201cFlows\u201d and click the \"Manage Flows\" dropdown, select the option \"Import Flows\". Select the json file you downloaded and click the option \"Import\".</li> <li>Click on the \"Go to Flow Designer\" icon to the right of the date modified of the flow that was just imported.</li> <li>Once you are in the Flow Designer, click the \"Edit\" toggle to switch to Edit mode. The first thing we want to do is to create the following flow variables by clicking anywhere in the canvas, not on a specific node. Click the button \u201cAdd Flow Variable\u201d and create the following variables:<ul> <li>Name = firstName, Variable Type = String</li> <li>Name = lastName, Variable Type = String</li> <li>Name = CJDS_ProjectID, Variable Type = String, Default Value = &lt;WorkspaceID&gt; (From Lab 1.2, step 2)</li> </ul> Flow Variables GIF </li> <li>Insert a new HTTP Request node AFTER the NewPhoneContact node. Make sure to connect the exit connection from the NewPhoneContact node to the incoming connection on this new node.  This new node will be used to send a query to the JDS service.<ul> <li>Rename the new HTTP Request node to JDS_Person_Query.</li> <li>On the Connector drop down select the WxCC_Read_Write.</li> <li>Set the Request Path to:     /admin/v1/api/person/workspace-id/{{CJDS_ProjectID}}/aliases/search</li> <li>Set the Method to: POST</li> <li>Set the Content Type to Application/JSON</li> <li>Enter the following JSON in the request body section:  <pre><code>{\n    \"identities\": [\"{{NewPhoneContact.ANI}}\"]\n}\n</code></pre></li> <li>Now edit the Parse Setting and set the following:<ul> <li>Content Type to JSON</li> <li>Output Variable = firstName</li> <li>Path Expression = $.data[0].firstName</li> </ul> </li> <li>Click Add New to include another output variable and set the following:<ul> <li>Output Variable = lastName</li> <li>Path Expression = $.data[0].lastName</li> </ul> </li> <li>Enable the decryption toggle in this node. </li> </ul> </li> <li>Add a menu node from the left node pallet to the canvas and move it below the JDS_Person_Query node you just added in the previous step.<ul> <li>Connect the exit of the JDS_Person_Query node to the entry of this new node.</li> <li>Turn on the \"Enable Text-to-Speech\" toggle, from the \"Connector\" drop down select \"Cisco Cloud text to speech\", and click the option \"Add Text-to-Speech message\". </li> <li>Delete the Audio File that is included by default. </li> <li>Inside the \"Text-to-Speech Message\" box, enter the following:  <pre><code>Welcome back {{firstName}} {{lastName}}. \nPress 1 to connect to our virtual agent. \nPress 2 to talk to a human agent.\n</code></pre></li> <li>Modify the menu links to match the options from the text-to-speech message. Add the digit number 1 and 2, include a description for each digit. </li> <li>Connect the output connection on digit 2 to the QueueContact node. </li> </ul> </li> <li>Insert a new HTTP Request node AFTER the Menu node. Make sure to connect the option 1 menu output to the incoming connection on this new node.  This new node will be used to post a new event to the JDS service.<ul> <li>Rename the new HTTP Request node to JDS_Event_Post.</li> <li>On the Connector drop down select the WxCC_Read_Write.</li> <li>Set the Request Path to:     /publish/v1/api/event?workspaceId={{CJDS_ProjectID}}</li> <li>Set the Method to: POST</li> <li>Set the Content Type to Application/JSON</li> <li>Enter the following JSON in the request body section: <pre><code>{\n    \"id\": \"{{NewPhoneContact.InteractionId}}\",\n    \"specversion\": \"1.0\",\n    \"type\": \"task:new\",\n    \"source\": \"IVR\",\n    \"identity\": \"{{NewPhoneContact.ANI}}\",\n    \"identitytype\": \"phone\",\n    \"datacontenttype\": \"application/json\",\n    \"data\": {\n        \"taskId\": \"{{NewPhoneContact.InteractionId}}\",\n        \"firstName\": \"{{firstName}}\",\n        \"lastName\": \"{{lastName}}\",\n        \"phone\": \"{{NewPhoneContact.ANI}}\",\n        \"channelType\": \"IVR\",\n        \"uiData\": {\n            \"title\": \"AI Agent Connect\",\n            \"iconType\": \"icon-headset_16\",\n            \"subTitle\": \"Self Service\",\n            \"filterTags\": [\"AI Agent\"]\n        }\n    }\n}\n</code></pre></li> <li>Enable the decryption toggle in this node.  </li> <li>Connect the output of this HTTP Request node to the entry point of the VirtualAgent V2 node. </li> </ul> </li> <li>Click the VAV2 Node and configure the following: <ul> <li>Contact Center AI Config: Webex AI Agent (Autonomous)</li> <li>Virtual Agent: JDS_Placeholder</li> </ul> JDS Placeholder AI Agent <p>You will create your own AI Agent in the next lab, this placeholder AI agent allows you to publish the flow and assign it to a channel to test that the CJDS query and post worked fine. </p> </li> <li>Click the QueueContact node and select the queue matching your POD number. </li> <li>Save and validate the flow, if there are no errors, proceed with publishing the flow. </li> <li>Go back to Control Hub and navigate to the Channels configuration. Find the channel matching your POD number and open it. Assign your new flow to the \"Routing Flow\" setting. Save changes. </li> </ol>"},{"location":"lab3_injecting_JDS_event/#testing","title":"Testing","text":"Instructions <ol> <li>Find the PSTN phone number in your POD channel. </li> <li>Call using the phone number you entered in the API collection. You should hear a welcome message with the name you entered in the postman variable in lab 2. </li> <li>Select the option 1 to connect to the virtual agent and when you hear it, disconnect the call. </li> <li>In Bruno, click on the \u201cGet History Stream by identity\u201d call and replace the identity with the phone number you used to call. Send the request and you should see a new AI Agent event in the JDS tape! </li> </ol> <p>Congratulations! You have completed LAB 3.  </p>"},{"location":"lab4_ai_agent_jds/","title":"Lab 4 - AI Agent Integration with CJDS","text":""},{"location":"lab4_ai_agent_jds/#webex-ai-agent-integration-with-cjds","title":"Webex AI Agent Integration with CJDS","text":"<p>Webex AI Agents allow you to use the power of GenAI inside our Customer Experience flows. Our Autonomous agents assist customers in real time by leveraging a knowledge base with Retrieval-Augmented Generation (RAG) techniques and executing actions through Webex Connect flows. This lab focuses on creating an AI Agent that can retrieve information from and post events to CJDS while supporting customer interactions.</p>"},{"location":"lab4_ai_agent_jds/#lab-41-create-an-ai-agent-and-a-knowledge-base","title":"Lab 4.1 Create an AI Agent and a Knowledge Base","text":"<p>To begin this lab, navigate to Control Hub and select the AI Agents card from the left pane of the Contact Center menu. Click the Build your AI Agent button. The AI Agent Studio will open in a new browser tab, where you will configure your AI Agent and Knowledge Base. </p> Create a Knowledge Base for your Webex AI Agent <ol> <li>From the AI Agent Studio, select the notebook icon on the left navigation menu. This is where you will manage your Knowledge Bases. </li> <li>Click Create Knowledge Base, enter the name as PODXX_AI_KB (replace the XX with your POD number), then click Create.</li> <li>Download this generic KB:  Webex_Sneakers_KB. </li> <li>Go to the Files tab and select the option Add File.</li> <li>Upload the Webex Sneakers KB and select the option Process Files.</li> </ol> Knowledge Base with Files Processed IMG <p></p> <p></p> Create your AI Agent <ol> <li>Navigate to Dashboard from the right-hand side menu panel and click Create Agent</li> <li>Select Start from Scratch and click Next</li> <li>On the Create an AI agent page, select the type of agent: Autonomous</li> <li>A new section called Add the essential details will appear. Enter the following information: <p>Agent Name: PODXX_JDS_AI (Replace the XX with the POD ID)</p> <p>System ID is created automatically</p> <p>AI engine: Webex AI Pro-US 1.0</p> </li> <li>In the Agent's goal section, enter the following: <p>Answer general questions about our online store, Webex Sneakers! Provide information about the customer orders and route to human agents when required.</p> </li> <li>Click Create on the bottom right corner. </li> <li>Once the agent is created, update the Welcome Message to say\"  <p>Hey! Welcome to Webex Sneakers! How can I help you? </p> </li> <li>Switch to Knowledge tab and from Knowledge base drop-down list select the knowledge base you created. </li> <li>Click Save Changes. </li> </ol> <p>You need to add Instructions to orchestrate how the AI Agent will execute an action, but first the Webex Connect flows have to be built. Let's do that! </p>"},{"location":"lab4_ai_agent_jds/#lab-42-build-connect-ai-agent-fulfillment-flows","title":"Lab 4.2 Build Connect AI Agent Fulfillment Flows.","text":"<p>Webex Connect has a powerful and intuitive flow builder tool, with its low-code/no-code approach it makes it easy for administrators to build fulfillment flows for our AI Agents.  In order to start this lab, go back to Control Hub and select the Overview card on the left pane. In the Quick Links section you will see the Webex Connect hyperlink, that will open in another tab of your browser. </p> Warning <p>The variables used in Webex Connect contain the node ID at the beginning, for example in this variable $(n4.Customer_ANI) the n4 is the node ID. This node ID might be different in your flow, so always double check that the node id matches. This can be done by double clicking the node that is generating the variable and looking at the node id on the bottom left corner. </p> Create Fulfillment Flows in Webex Connect <ol> <li>Find the Service matching your POD ID and click it. </li> <li>This will open the dashboard section of your service, click the flows tab to start building. </li> <li>Let's start by building a Connect flow that allows the AI Agent to fetch the caller details:<ul> <li>Select the option Create Flow and add the name JDS_Identity. Click the \"Create\" button. </li> <li>This opens the trigger category page, select the AI Agent integration trigger. </li> <li>Now you should see the Configure AI Agent Event window open up. In the sample JSON box, remove all of the default values and just leave an empty JSON, like this:  <pre><code>{}\n</code></pre></li> <li>Click the Parse blue button and hit save.</li> </ul> JDS_Identity Trigger IMG <p></p> <p></p> <ul> <li>From the Node Palette on the left, drag and drop an Evaluate node into the canvas. Connect the AI Agent node to the Evaluate node. Double click the Evaluate node and enter this code:  <pre><code>var ANItoTime = Date.now() + \"\";\nvar lookbacktime = ANItoTime - 30000;\nvar ANIfromTime = lookbacktime + \"\";\n1;\n</code></pre></li> <li>In the same node, enter the number 1 in the Script Output field and in the Branch Name enter the word Success. Hit Save. </li> </ul> JDS_Identity Evaluate IMG <p></p> <p></p> <ul> <li>Let's add another node, look for a node called WxCC API and bring it to the canvas. Connect the Evaluate green output to this new node. Double Click the WxCC API node and enter the following information:  <p>From: $(ANIfromTime)</p> <p>To: $(ANItoTime)</p> <p>Corrid: $(corrid)</p> </li> <li>Hit Save. </li> </ul> JDS_Identity WxCC API IMG <p></p> <p></p> <ul> <li>Now we are ready to use the CJDS node from Webex Connect, in the node palette find the node called Journey and bring it into the canvas. </li> <li>Connect the success output of the WxCC API node into the Journey node. Double click it and fill out the fill out the following:  <p>Method Name: Get Identity by Aliases</p> <p>Node Authentication: JDS_CPaaS</p> <p>Project Name: Customer-Journey-Widget</p> <p>Aliases: $(n4.Customer_ANI)</p> </li> <li>Click the Save button. </li> </ul> JDS_Identity Journey IMG <p></p> <p></p> <ul> <li>Go into the flow Settings by clicking the gear icon on the top right corner. From here, select the Flow Outcomes tab and expand the Last Execution Status menu. </li> <li>In this menu you can configure what is going to be sent back to the AI Agent when the action is executed. For this scenario, we want to send back the customer phone number, first name and last name. In the key value section, add the following variables:  Key Value firstName $(n5.firstName) lastName $(n5.lastName) phoneNumber $(n4.Customer_ANI) </li> </ul> JDS_Identity Outcome IMG <p></p> <p></p> <ul> <li>Click the Save button. Also, click the Save button for the flow on the top right corner and then click on Make Live. A window will pop up, click the Make Live option. </li> <li>Exit the flow from the top left corner. </li> <li>As an explanation of the flow, the AI Agent will trigger this flow to collect the user details from CJDS. In order to do this, you configured the Evaluate node to get the current time in epoch format and then you are using those values to run a Search API with the WxCC API node. This Search API returns the Customer ANI number, then this is used in the Journey node to collect the person profile details. </li> </ul> JDS_Identity Final Flow IMG <p></p> <p></p> </li> <li>Now let's build a Fulfillment flow to check the status of an order from an external DB: <ul> <li>Select the option Create Flow and add the name CheckOrder. Click the \"Create\" button. </li> <li>This opens the trigger category page, select the AI Agent integration trigger. </li> <li>Now you should see the Configure AI Agent Event window open up. In the sample JSON box, enter the following information:  <pre><code>{\n\"phone\": \"\",\n\"accountNumber\": \"\"\n}\n</code></pre></li> <li>Click the Parse blue button and hit save.</li> </ul> Check Order Trigger IMG <p></p> <p></p> <ul> <li>From the Node Palette on the left, drag and drop an HTTP Request node into the canvas. Connect the AI Agent node to the HTTP Request node. Double click the HTTP Request and setup the following fields: </li> <li>Method: GET</li> <li>Endpoint URL: https://66d8867237b1cadd8054f426.mockapi.io/CustomerDatabase?AccountNumber=$(n2.aiAgent.accountNumber)</li> <li>Connection Timeout: 10000</li> <li>Request Timeout: 10000</li> <li>Output Variables:  Output Variable Name Response Entity Response Path FirstName Body $[0].First LastName Body $[0].Last Product Body $[0].Product InitialArrival Body $[0].initialArrival CurrentArrival Body $[0].currentArrival PaymentType Body $[0].paymentType OrderStatus Body $[0].orderStatus </li> <li>Click the Save button.</li> </ul> Check Order HTTP Request IMG <p></p> <p></p> <ul> <li>Drag and drop the Journey node into the canvas. Connect the success output of the HTTP Request node into the Journey node. Double click it and fill out the fill out the following:  <p>Method Name: Write to CJDS</p> <p>Node Authentication: JDS_CPaaS</p> <p>Project Name: Customer-Journey-Widget</p> <p>Request Body Object: Complete Object</p> <p>Request Body Object JSON:  </p><pre><code>{\n   \"id\":\"$(n2.aiAgent.transId)\",\n   \"specversion\":\"1.0\",\n   \"type\":\"Order Status\",\n   \"source\":\"IVR\",\n   \"identity\":\"$(n2.aiAgent.phone)\",\n   \"identitytype\":\"phone\",\n   \"datacontenttype\":\"application/json\",\n   \"data\":{\n      \"taskId\":\"$(corrid)\",\n      \"firstName\":\"$(n3.FirstName)\",\n      \"lastName\":\"$(n3.LastName)\",\n      \"phone\":\"$(n2.aiAgent.phone)\",\n      \"product\":\"$(n3.Product)\",\n      \"paymentType\":\"$(n3.PaymentType)\",\n      \"channelType\":\"IVR\",\n      \"initialArrival\":\"$(n3.InitialArrival)\",\n      \"currentArrival\":\"$(n3.CurrentArrival)\",\n      \"uiData\":{\n         \"title\":\"Check Order Status\",\n         \"iconType\":\"\",\n         \"subTitle\":\"$(n3.OrderStatus)\",\n         \"filterTags\":[\n            \"Order Status\"\n         ]\n      }\n   }\n}\n</code></pre><p></p> </li> <li>Click the Save button. </li> </ul> Check Order Journey IMG <p></p> <p></p> <ul> <li>Go into the flow Settings by clicking the gear icon on the top right corner. From here, select the Flow Outcomes tab and expand the Last Execution Status menu. </li> <li>In the key value section, add the following variables:  Key Value product $(n3.Product) paymentType $(n3.PaymentType) InitialArrival $(n3.InitialArrival) CurrentArrival $(n3.CurrentArrival) OrderStatus $(n3.OrderStatus) </li> </ul> Check Order Outcome IMG <p></p> <p></p> <ul> <li>Click the Save button. Also, click the Save button for the flow on the top right corner and then click on Make Live. A window will pop up, click the Make Live option. </li> <li>Exit the flow from the top left corner. </li> </ul> Check Order Final Flow IMG <p></p> <p></p> </li> <li>We are down to our last fulfillment flow, this will be a SMS Deflection flow. The AI Agent will offer customers to use our SMS digital channel: <ul> <li>Select the option Create Flow and add the name SMS_Deflection. Click the \"Create\" button. </li> <li>This opens the trigger category page, select the AI Agent integration trigger. </li> <li>Now you should see the Configure AI Agent Event window open up. In the sample JSON box, enter the following information:  <pre><code>{\n  \"phone\": \"\",\n  \"firstName\": \"\",\n  \"lastName\": \"\"\n}\n</code></pre></li> <li>Click the Parse blue button and hit save.</li> </ul> SMS Deflection Trigger IMG <p></p> <p></p> <ul> <li>From the Node Palette on the left, drag and drop a SMS node into the canvas. Connect the AI Agent node to the SMS node. Double click the SMS and setup the following fields: <p>Destination Type: msisdn</p> <p>Destination: $(n2.aiAgent.phone)</p> <p>From Number: Select the SMS number assigned to your POD</p> <p>Message Type: Text</p> <p>Message: Thank you for accepting to try our customer support service over digital channels! If this is a good moment to connect you to an agent, please reply with the phrase \"GoToQueue\".</p> </li> <li>Click the Save button.</li> </ul> SMS Deflection SMS IMG <p></p> <p></p> <ul> <li>Drag and drop the Journey node into the canvas. Connect the success output of the SMS node into the Journey node. Double click it and fill out the fill out the following:  <p>Method Name: Write to CJDS</p> <p>Node Authentication: JDS_CPaaS</p> <p>Project Name: Customer-Journey-Widget</p> <p>Request Body Object: Complete Object</p> <p>Request Body Object JSON:  </p><pre><code>{\n  \"id\":\"$(n2.aiAgent.transId)\",\n  \"specversion\":\"1.0\",\n  \"type\":\"SMSDeflection\",\n  \"source\":\"IVR\",\n  \"identity\":\"$(n2.aiAgent.phone)\",\n  \"identitytype\":\"phone\",\n  \"datacontenttype\":\"application/json\",\n  \"data\":{\n     \"taskId\":\"$(corrid)\",\n     \"firstName\":\"$(n2.aiAgent.firstName)\",\n     \"lastName\":\"$(n2.aiAgent.lastName)\",\n     \"phone\":\"$(n2.aiAgent.phone)\",\n     \"channelType\":\"IVR\",\n     \"uiData\":{\n        \"title\":\"Digital Channel Deflection\",\n        \"iconType\":\"icon-sms_16\",\n        \"subTitle\":\"SMS\",\n        \"filterTags\":[\n           \"Digital Channel Deflection\"\n        ]\n     }\n  }\n}\n</code></pre><p></p> </li> <li>Click the Save button. </li> </ul> SMS Deflection Journey IMG <p></p> <p></p> <ul> <li>Click the Save button. Also, click the Save button for the flow on the top right corner and then click on Make Live. A window will pop up, click the Make Live option. </li> <li>Exit the flow from the top left corner. </li> </ul> SMS Deflection Final Flow IMG <p></p> <p></p> </li> </ol>"},{"location":"lab4_ai_agent_jds/#lab-43-ai-agent-instructions-and-actions","title":"Lab 4.3 AI Agent Instructions and Actions","text":"<p>In this section, you will setup AI Agent actions that use the fulfillment flows created in the previous section. Also, you will add the instructions on when to use those actions. </p> Create Actions <ol> <li>Switch to the Actions tab and click the New action button. Proceed to name the action JDS_Identity, add a description and select the Action Scope option called Slot filling and fulfillment. </li> <li> <p>In the Webex Connect Flow Builder Fulfillment section, select the POD XX service and the flow JDS_Identity. Click the \"Add\" button. </p> JDS Identity Action IMG <p></p> <p></p> </li> <li> <p>Click the New action button again, and proceed to name the action Check_Order, add a description and select the action scope option called Slot filling and fulfillment. </p> </li> <li>Create new input entities for the data required to check the order status, these are the details for each entity:  Entity Name Type Value Description accountNumber number - account number, 8 digits phone phone Use default regex A valid phone number with country code. This phone number will be returned from the JDS_Identity action. </li> <li> <p>In the Webex Connect Flow Builder Fulfillment section, select the POD XX service and the flow CheckOrder. Click the \"Add\" button.  </p> Check Order Action IMG <p></p> <p></p> </li> <li> <p>Click the New action button again, and proceed to name the action SMS_Deflection, add a description and select the action scope option called Slot filling and fulfillment. </p> </li> <li>Create new input entities for the data required to send a SMS to the user, these are the details for each entity:  Entity Name Type Value Description firstName string - This variable was returned from the JDS_Identity action. Do not ask the user. lastName string - This variable was returned from the JDS_Identity action. Do not ask the user. phone phone Use default regex A valid phone number with country code. This phone number will be returned from the JDS_Identity action. </li> <li> <p>In the Webex Connect Flow Builder Fulfillment section, select the POD XX service and the flow SMS_Deflection. Click the \"Add\" button.  </p> SMS Deflection Action IMG <p></p> <p></p> List of Actions IMG <p></p> <p></p> </li> <li> <p>Go back to the Profile tab on the AI Agent configuration page. In the instructions section, enter the following:  </p><pre><code># Instructions\n  **Execute step 1 before answering any questions or triggering any other actions**\n  1. Inform the user that you will fetch their details, do this by executing the action JDS_Identity. \n  2. After getting the user details from the JDS_Identity action, greet the user by their first and last name. \n  3. Answer the user questions. \n  4. If the user wants to check their order status, collect their account number and use the action Check_Order to get the details. \n  5. If there are any issues with the order (delays, lost in transit, etc), ask the user if they want to proceed with a refund or replacement. Use the {{initialArrival}} and {{currentArrival}} dates to verify how much time the order has been delayed or lost. **Follow policies from the KB to determine if you can process the refund** \n  6. **Voice Channel Only** If the user wants to talk to a human agent or the company policies require you to do the transfer, first offer the user if they would like to continue this transaction over SMS. Inform them that our digital queue is faster and this way they won't have to wait long times on queue.  \n  7. If they accept, trigger the action SMS_Initiate and inform the user they will receive a SMS shortly.\n</code></pre><p></p> </li> <li> <p>Click the option Save Changes and then Publish, provide any version name. Your AI Agent is now ready for testing.</p> Final AI Agent IMG <p></p> <p></p> </li> </ol>"},{"location":"lab4_ai_agent_jds/#testing","title":"Testing","text":"<p>In Lab 3 you configured a voice flow and selected a placeholder AI Agent in the VA V2 node, go back to your voice flow and update that node to use your new AI Agent. Once you make the changes, remember to validate and publish your IVR flow. Once this is done, here's what you can do to test: </p> Testing AI Agent Integration with CJDS <ol> <li>Place a call to your voice flow and select option 1 in the menu. </li> <li>Ask a couple of questions that are included in the Knowledge Base file you uploaded, for example: <ul> <li>Are there any ongoing promotions? </li> <li>How long does shipping normally take? </li> <li>Are your sneakers authentic? </li> </ul> </li> <li>After you get some answers, ask about your order status. </li> <li>It should tell you the order is delayed, but that it can't help with a refund or replacement for you because of store policies. </li> <li>Insist that you want a refund and the AI Agent should offer you to use the SMS channel to talk to a human agent. Say yes and you should receive a SMS (Only US numbers). </li> <li>Go to your Agent Desktop and on the JDS widget do a search for your phone number, you should see the events pushed from the AI Agent for Order Status and SMS Deflection. </li> </ol> <p>You have completed the JDS 2851 Lab, Congratulations! </p>"},{"location":"lab5_CC_subscription_JDS/","title":"Using CC data in JDS","text":""},{"location":"lab5_CC_subscription_JDS/#using-cc-data-in-jds","title":"Using CC data in JDS","text":"<p>Subscription Connect webhook Process data and trigger actions</p>"},{"location":"lab_novapay/","title":"Extra Lab - NovaPay Payment Service","text":""},{"location":"lab_novapay/#lab-purpose","title":"Lab Purpose","text":"<p>The purpose of this lab is to build a fake payment service for demo purposes. The outcome of this lab is twofod: </p> <ol> <li> <p>A mockpayment frontend web site that mimics a typical payment user interface. The frontend offers a user interface to enter the payment data: amount, card option (visa, master card...) and  card details (name, number, expiration date and cvv). It allows a user to enter the data and click on a pay button to confirm the payment. The web site responds with a confirmation message that the payment has been completed. The user will see the amount payed, the last 4 digits of its credit card and a mock confirmation number.</p> Warning <p>This is a UI simulation only. It does not process real payments, store data, or connect to any backend.</p> <p>Note: The application does not run any format validation on the input data</p> </li> <li> <p>A web service that exposes an API to allow a third party to open a payment session for the customer to pay and complete the payment. It also provides the session status to check whether the payment has been completed. </p> </li> </ol> <p>This lab provides a step-by-step guide to replicate and deploy your own version of the NovaPay Payment Service using the existing implementation available in the Novapay GitHub repository.</p>"},{"location":"lab_novapay/#pre-requisites","title":"Pre-Requisites","text":"<p>This section outlines the required technologies, platforms, and applications needed to build, deploy, and operate the NovaPay Mock Payment Service.</p> <p>The implementation of the service relies on a lightweight web-based architecture composed of a hosted frontend, a backend API layer, a persistent session store, and an external Desktop Agent application capable of invoking REST APIs.</p>"},{"location":"lab_novapay/#required-components","title":"Required components","text":"<p>The following table summarizes the core components required to implement the NovaPay payment service:</p> Service Component Role in NovaPay GitHub Frontend Hosting the static payment page and version control for the entire codebase. Render Backend Cloud hosting for the Node.js/Express API (Session management &amp; processing). Redis Cloud Database Providing a managed Key-Value store for persistent, fast session storage."},{"location":"lab_novapay/#required-applications-and-accounts","title":"Required Applications and Accounts","text":"<p>In order to successfully deploy the NovaPay service, the following applications and user accounts must be available:</p> <ol> <li> <p>Development Environment</p> <ul> <li> <p>Node.js (v18 or later recommended) - Required to run the backend API locally. Includes npm for dependency management</p> </li> <li> <p>Git - Required for source code version control, Used to push backend and frontend code to GitHub</p> </li> <li> <p>Code Editor - Recommended: Visual Studio Code (VSCode). Used to develop and modify backend and frontend files</p> </li> </ul> </li> <li> <p>Hosting &amp; Deployment Platforms</p> <ul> <li> <p>GitHub Account: Host the frontend payment page via GitHub Pages. Store backend implementation code</p> </li> <li> <p>Render Account: Deploy the NovaPay Backend API as a Web Service and deploy the Redis Key-Value Store instance. It also manages environment variables</p> </li> </ul> </li> <li> <p>Testing Tools</p> <ul> <li>Postman (or Bruno or similar API client) - Test NovaPay REST APIs. Simulates client app behavior and validates session creation and payment confirmation.</li> </ul> </li> </ol>"},{"location":"lab_novapay/#general-overview-of-the-novapay-payment-service","title":"General overview of the NovaPay payment service.","text":"<p>NovaPay is a mock payment service designed for developer testing and integration purposes. It provides a simple, secure payment flow where an agent can generate a payment session, share a frontend URL with a customer, and confirm the payment. The service stores session data in Redis and allows polling from a desktop or web application to verify payment completion.</p>"},{"location":"lab_novapay/#architecture-overview","title":"Architecture Overview","text":"<pre><code>flowchart LR\n    A[Client App]\n    B[NovaPay API, Node.js + Express]\n    C[Redis DB, Session Store]\n    D[Customer Frontend, GitHub Pages]\n\n    A --&gt;|Create session and poll status| B\n    B --&gt;|Store session| C\n    B --&gt;|Respond with session status| A\n    A --&gt;|Send payment URL| D\n    D --&gt;|Submit payment info| B\n    B --&gt;|Update session in Redis| C\n</code></pre>"},{"location":"lab_novapay/#lab-overview","title":"\ud83d\udccc Lab Overview","text":"<p>In this lab you will perform the following tasks:</p> <ol> <li>Replicate the NovaPay GitHub Repository  </li> <li>Configure GitHub Pages to host the payment frontend  </li> <li>Deploy the Backend API on Render  </li> <li>Deploy the Redis Key-Value Store on Render  </li> <li>Configure environment variables  </li> <li>Test NovaPay APIs using Postman  </li> </ol>"},{"location":"lab_novapay/#step-1-replicate-the-novapay-repository","title":"\ud83d\udd39 STEP 1 \u2014 Replicate the NovaPay Repository","text":"<p>You will create your own copy of the NovaPay implementation in your own repository. Currently, all the assets for the service are located in a GitHub hosted repository: Novapay, owned by Cisco.</p> Import NovaPay GitHub Repository <ol> <li>Log in to your GitHub Account</li> <li>Navigate to: Import Repository </li> <li>Populate the fields as follows:</li> </ol> Field Value Repository URL https://github.com/cx-partner/NovaPay Owner Your GitHub Username Repository Name NovaPay Import the Repository to GitHub <p></p> <p></p> <ol> <li>Click: Begin Import</li> </ol> <p>GitHub will start importing the repository. After completion, you will have your own NovaPay repository in GitHub:</p> <pre><code>https://github.com/&lt;your-username&gt;/NovaPay\n</code></pre>"},{"location":"lab_novapay/#step-2-configure-github-pages-frontend-hosting","title":"\ud83d\udd39 STEP 2 \u2014 Configure GitHub pages (Frontend Hosting)","text":"<p>The NovaPay frontend that hosts the user interface is hosted publicly using GitHub Pages.</p> Enable GitHub Pages <p>Let\u00b4s first enable GitHub Pages in your new repository. </p> <ol> <li> <p>Navigate to your repository in GitHub</p> <pre><code>NovaPay \u2192 Settings \u2192 Pages\n</code></pre> </li> <li> <p>Under Source, select: Deploy from Branch</p> </li> <li> <p>Under Branch, select: </p> <ul> <li>Branch: main</li> <li>Folder: /(root)</li> </ul> </li> <li> <p>Click on Save</p> </li> </ol> Enable GitHub Pages <p></p> <p></p> Obtain your Frontend URL <p>Once GitHub pages is deployed, GitHub generates a public URL for you: </p> <pre><code>https://&lt;your-username&gt;.github.io/NovaPay/backend/frontend/index.html\n</code></pre> <p>If you try this URL, you will get to the NovaPay payment service web site. Try it!</p> <p>Take note of this URL. You will need it later. </p> The NovaPay payment Website <p></p> <p></p>"},{"location":"lab_novapay/#step-3-deploy-backend-api-on-render","title":"\ud83d\udd39 STEP 3 \u2014 Deploy Backend API on Render","text":"Create Render Account <p>If you do not have a Render account, navigate to:</p> <p>Render </p> <p>Create an account:     1. Click on Start for free     2. Create your render account</p> Leverage your GitHub user <p>Select the GitHub option and enter yout GitHub credentials. That will connect your render workspace with your GitHub environment.</p> Create a Render user <p></p> <p></p> Create your Web Service <ol> <li> <p>Select:     </p><pre><code>New -&gt; Web Service\n</code></pre><p></p> </li> <li> <p>Under Git Provider, select your NovaPay Repository</p> </li> <li> <p>Populate the configuration</p> Field Value Name NovaPay Region Select the region that best suits you Root Directory backend Environment Node Build Command npm install Start Command node server.js </li> <li> <p>Select the Instance Type (free will work) and Click on Create Web Service</p> </li> </ol> <p>Render will start building your service and then it will be deployed. After a while, you will see your service Live</p> Warning <p>With the free instance option, your free instance will spin down with inactivity, which can delay requests by 50 seconds or more.</p> Create a Render Web Service <p></p> <p></p>"},{"location":"lab_novapay/#-select-github","title":"- Select GitHub","text":""},{"location":"lab_novapay/#step-4-deploy-redis-key-value-store","title":"\ud83d\udd39 STEP 4 \u2014 Deploy Redis Key-Value Store","text":"Create Redis Instance <p>As we are implementing a polling architecture, we need something that can persist payment session state outside of the API process and make it quickly retrievable across multiple stateless requests. Our backend service running in Render is stateless, containerized and restartable at any moment, so we cannot store session state in memory inside Node.js. That\u2019s exactly why Redis is required.</p> <ol> <li>In Render, add a new Key Value     <pre><code>+ New -&gt; Key Value\n</code></pre></li> <li> <p>Populate: </p> Field Value Name novapay_redis Region same as for the Web Service Plan Free </li> <li> <p>Click Create Key Value Instance</p> </li> </ol> Create Redis Instance <p></p> <p></p> Obtain Redis Internal URL <ol> <li> <p>After creation, navigate to </p> <p><code>novapay-redis \u2192 Info</code> </p> </li> <li> <p>Scroll down to the Internal Key Value URL</p> <p><code>Example: redis://red-d6g98xxxxxxc73daj4vg:6379</code></p> </li> <li> <p>Copy it, you will need it later. </p> </li> </ol> Redis internal URL <p></p> <p></p>"},{"location":"lab_novapay/#step-5-configure-environment-variables","title":"\ud83d\udd39 STEP 5 \u2014 Configure Environment Variables","text":"<p>We need to define a couple of environmental variables. Navigate to your workspace. You should see your two active services now.</p> NovaPay services in Render <p></p> <p></p> Novapay Environment Variables <ol> <li>Click on the Novapay service</li> <li>In the Left Navigation menu, click on Environment</li> <li> <p>Under Environment Variables, add the following variables:</p> Key Value REDIS_URL The Internal Redis URL you copied above FRONTEND_URL https://.github.io/NovaPay/backend/frontend </li> <li> <p>Click on Save, Rebuild and Deploy</p> </li> </ol> Novapay Environment Variables <p></p> <p></p>"},{"location":"lab_novapay/#step-6-verify-deployment","title":"\ud83d\udd39 STEP 6 \u2014 Verify Deployment","text":"<p>Once deployed, your NovaPay API will be accessible via:</p> <p><code>https://&lt;your-render-url&gt;.onrender.com</code></p> <p>where your-render-url is of the type novapay-xxxx</p> <p>Verify the backend health: </p> <p><code>GET https://&lt;your-render-url&gt;.onrender.com/health</code></p> <p>Expected response:   Backend is running</p>"},{"location":"lab_novapay/#step-7-frontend-configuration-changes-indexhtml","title":"\ud83d\udd39 STEP 7 \u2014 Frontend Configuration Changes (index.html)","text":"<p>Your frontend is hosted using GitHub Pages, but it still references the old backend endpoint from the original service. You must update the NovaPay API URL in the payment page to your own API.</p> Frontend adaptation <ol> <li>in GitHub, navigate to      <code>backend/frontend/index.html</code></li> <li> <p>Locate the Backend API reference in the file. Find the section in the javascript code where the backend Novapay API is called. </p> <pre><code>const response = await fetch(\"https://novapay-2590.onrender.com/api/pay\"\n</code></pre> </li> <li> <p>Replace the API URL with the URL of your own NovaPay API. (you simply need to replay the four characters following novapay-)</p> </li> </ol> Warning <p>Do not forget to commit and push any change in GitHub. Render will automatically trigger a new deployment for the service. </p>"},{"location":"lab_novapay/#step-8-test-apis-using-postman","title":"\ud83d\udd39 STEP 8 \u2014 Test APIs Using Postman","text":"Warning <p>Test can be done with Bruno or Postman clients. In any case, make sure the desktop versions are installed in the laptop, do not use any web versions. </p> Create a Payment session <ul> <li>Request:      <code>POST /api/create-session</code></li> <li>URL:      <code>https://novapay-xxxx.onrender.com/api/create-session</code></li> <li>Body:     <pre><code>{\n    \"amount\": 120,\n    \"customerEmail\": \"test@test.com\",\n    \"agentId\": \"agent01\"\n}\n</code></pre></li> <li>Response:     <pre><code>{\n    \"sessionId\": \"xxxx\",\n    \"paymentUrl\": \"https://&lt;your-username&gt;.github.io/NovaPay/backend/frontend/index.html?sessionId=xxxxxx&amp;amount=xxx\"\n}\n</code></pre></li> </ul> Verify Payment status <ul> <li>Request:      <code>GET /api/session-status</code></li> <li>URL:      <code>https://novapay-xxxx.onrender.com/api/session-status?sessionId=xxxx</code></li> <li> <p>Response:     Payment pending:      </p><pre><code>{\n    \"agentId\": \"agent123\",\n    \"amount\": 2500,\n    \"customerEmail\": \"jucorral@cisco.com\",\n    \"status\": \"pending\"\n}\n</code></pre><p></p> <p>Payment completed: </p><pre><code>{\n    \"agentId\": \"agent123\",\n    \"amount\": 2500,\n    \"customerEmail\": \"jucorral@cisco.com\",\n    \"status\": \"completed\",\n    \"last4\": \"1234\",\n    \"confirmationCode\": \"NP-47QXLJCS\"\n}\n</code></pre><p></p> </li> </ul> Execute Payment <ul> <li>Request:      <code>POST /api/pay</code></li> <li>URL:      <code>https://novapay-xxxx.onrender.com/api/pay</code></li> <li>Request:     <pre><code>{\n  \"sessionId\": \"123434523452345\",\n  \"amount\": 432421,\n  \"cardNumber\": \"1234123412341234\",\n  \"cardName\": \"John Doe\",\n  \"expiry\": \"12/27\",\n  \"cvv\": \"123\"\n}\n</code></pre></li> <li>Response:     <pre><code>{\n    \"status\": \"success\",\n    \"amount\": 2500,\n    \"last4\": \"1234\",\n    \"confirmationCode\": \"NP-47QXLJCS\"\n}\n</code></pre></li> </ul> Server Healthcheck <ul> <li>Request:      <code>GET /health</code></li> <li>URL:      <code>https://novapay-xxxx.onrender.com/health</code></li> <li>Response:     <code>Backend is running</code></li> </ul>"},{"location":"lab_novapay/#lab-completion","title":"\u2705 Lab Completion","text":"<p>At this point, you have successfully:</p> <ul> <li> <p> Replicated the NovaPay Service</p> </li> <li> <p> Hosted the Payment Frontend via GitHub Pages</p> </li> <li> <p> Deployed the Backend API on Render</p> </li> <li> <p> Configured Redis for Persistent Sessions</p> </li> <li> <p> Tested Payment Session Creation</p> </li> <li> <p> Completed a Mock Payment Transaction</p> </li> <li> <p> Retrieved Payment Confirmation via API</p> </li> </ul> <p>You now have a fully operational NovaPay Mock Payment Service running on the Internet.</p>"},{"location":"lab_novapay/#troubleshooting-guide","title":"\ud83d\udee0\ufe0f Troubleshooting Guide","text":"<p>This section describes the most common issues encountered during the deployment and testing of the NovaPay Payment Service, along with recommended solutions.</p> \u274c 1. GitHub Pages Payment Page Shows 404 Error <p>\ud83d\udd0d Symptoms</p> <p>When accessing the payment URL:</p> <pre><code>https://&lt;yourusername&gt;.github.io/novapay/?sessionId=12345\n</code></pre> <p>You receive:</p> <pre><code>404 Page Not Found\n</code></pre> <p>\u2705 Possible Causes &amp; Solutions</p> Cause Solution GitHub Pages not enabled Go to Repository \u2192 Settings \u2192 Pages and enable deployment from <code>main</code> branch Wrong folder selected Ensure GitHub Pages is configured to deploy from <code>/root</code> Repository renamed but URL not updated Update payment URL in <code>server.js</code> Changes not committed Commit and push latest changes to GitHub \u274c 2. Payment Page Loads but Shows \"Session Not Found\" <p>\ud83d\udd0d Symptoms</p> <p>The payment page opens correctly but displays:</p> <pre><code>Session Not Found\n</code></pre> <p>\u2705 Possible Causes &amp; Solutions</p> Cause Solution Backend API URL still pointing to MockPayment Update API endpoint in <code>/frontend/index.html</code> Backend service not running in Render Verify deployment status in Render dashboard Session expired in Redis Recreate payment session via Postman Incorrect <code>sessionId</code> in URL Ensure sessionId is passed correctly \u274c 3. Backend Fails to Connect to Redis <p>\ud83d\udd0d Symptoms</p> <p>Render logs show:</p> <pre><code>Error: connect ECONNREFUSED 127.0.0.1:6379\n</code></pre> <p>\u2705 Possible Causes &amp; Solutions</p> Cause Solution Redis URL still set to localhost Replace Redis config in <code>/backend/server.js</code> Missing environment variable Add <code>REDIS_URL</code> in Render Environment settings Redis instance not created Create Redis service in Render dashboard Using External instead of Internal URL Use Internal Redis URL from Render \u274c 4. CORS Error When Loading Payment Session <p>\ud83d\udd0d Symptoms</p> <p>Browser developer console shows:</p> <pre><code>Access to fetch at 'https://novapay-api.onrender.com' from origin 'https://yourusername.github.io' has been blocked by CORS policy\n</code></pre> <p>\u2705 Solution</p> <p>Ensure CORS is enabled in your backend.</p> <p>Install CORS middleware:</p> <pre><code>npm install cors\n</code></pre> <p>Add the following to your server.js:</p> <pre><code>const cors = require(\"cors\");\napp.use(cors());\n</code></pre> <p>Commit and push changes to redeploy in Render.</p> \u274c 5. Render Deployment Fails During Build <p>\ud83d\udd0d Symptoms</p> <p>Deployment logs show:</p> <pre><code>npm ERR! missing script: start\n</code></pre> <p>\u2705 Solution</p> <p>Ensure your /backend/package.json includes:</p> <pre><code>\"scripts\": {\n\"start\": \"node server.js\"\n}\n</code></pre> <p>Commit and push changes to GitHub to trigger a new deployment.</p> \u274c 6. Postman API Tests Fail <p>\ud83d\udd0d Symptoms</p> <p>Requests to create or retrieve payment sessions return:</p> <pre><code>500 Internal Server Error\n</code></pre> <p>\u2705 Possible Causes &amp; Solutions</p> Cause Solution Backend not deployed Verify Render deployment Redis not connected Check REDIS_URL environment variable Incorrect API endpoint Confirm Postman uses Render backend URL Missing headers Add <code>Content-Type: application/json</code> \u274c 7. Payment Status Never Updates (Desktop Polling) <p>\ud83d\udd0d Symptoms</p> <p>Desktop agent keeps polling but always receives:</p> <pre><code>status: pending\n</code></pre> <p>\u2705 Possible Causes &amp; Solutions</p> Cause Solution Payment not submitted Click \"Confirm Payment\" in frontend Frontend not updating session Verify POST <code>/pay</code> request is sent Backend Redis write failing Check Render logs Polling wrong sessionId Confirm same sessionId used <p>\ud83d\udd0e Useful Debugging Tips</p> <ul> <li> <p>Check Render Logs under:</p> <pre><code>NovaPay Service \u2192 Logs\n</code></pre> </li> <li> <p>Use browser Developer Tools \u2192 Network Tab to inspect API calls.</p> </li> <li> <p>Validate Redis connectivity from backend logs.</p> </li> <li> <p>Confirm GitHub Pages URL loads without query parameters first.</p> </li> </ul> <p>\u2705 After resolving these issues, your NovaPay service should be fully operational and ready for Desktop polling integration and API testing.</p>"},{"location":"overview/","title":"Overview","text":""},{"location":"overview/#overview","title":"Overview","text":""},{"location":"overview/#introduction-to-the-bootcamp","title":"Introduction to the Bootcamp","text":"<p>This bootcamp focuses on a high-impact use case for Retail Banking (FinServ): </p> <p>Proactive Debt Collection and Contention Resolution </p> <p>We will see how streamlining debt recovery can be achieved while enhancing customer experience. The scenario centers on a proactive journey where the bank identifies customers with upcoming debt maturity dates and initiates contact through automated channels.</p> <p>The strategy is divided into two phases:</p> <ol> <li>Proactive Outbound &amp; AI Agent Automation: Using AI to handle routine payments and inquiries securely.</li> <li>Contention Escalation &amp; AI-Assisted Resolution: Transitioning to human experts when a customer disputes a transaction, supported by real-time AI guidance to resolve fraud concerns and lock compromised cards.</li> </ol> <p>Participants will explore a \"frictionless\" journey where customers are notified of upcoming debt maturity dates and provided with instant, secure payment options. The bootcamp also covers complex \"contention\" scenarios, where AI-assisted human agents step in to resolve disputes, lock compromised cards, and ensure regulatory compliance.</p>"},{"location":"overview/#learning-objectives","title":"Learning Objectives","text":"<p>Participants will gain hands-on experience in the following areas:</p> <ul> <li>Proactive Engagement: Configuring the Native Campaign Manager to trigger outbound voice calls based on database maturity dates.</li> <li>AI-Driven Automation: Building AI Agent flows that can authenticate users, query debt databases, and process payments via API.</li> <li>Frictionless Payments: Integrating with NovaPay to generate unique payment URLs delivered via SMS or Email.</li> <li>Contextual Escalation: Implementing seamless handovers from AI to Human Agents, ensuring all context (VA Summary) is preserved.</li> <li>Agent Empowerment: Utilizing RT Assist (Real-Time Assist) to guide agents through complex compliance steps, such as card locking and address verification.</li> <li>Operational Efficiency: Automating post-call work using AI-generated Wrap-Up summaries.</li> </ul>"},{"location":"overview/#bootcamp-structure-labs","title":"Bootcamp Structure: Labs","text":"<p>The bootcamp is organized into four core labs that follow the lifecycle of the debt collection use case:</p>"},{"location":"overview/#lab-1-proactive-outbound-reach-campaign-manager","title":"Lab 1: Proactive Outbound Reach (Campaign Manager)","text":"<p>Configure the Native Campaign Manager to trigger calls based on debt maturity dates and manage retry logic.</p>"},{"location":"overview/#lab-2-automated-customer-engagement-ai-agent","title":"Lab 2: Automated Customer Engagement (AI Agent)","text":"<p>Build an AI Agent flow that integrates with the Customer Debt DB and NovaPay API to handle payments and inquiries independently.</p>"},{"location":"overview/#lab-3-value-of-the-human-touch-escalation","title":"Lab 3: Value of the Human Touch (Escalation)","text":"<p>Design the escalation path to a specialized \"Financial Contention\" queue, ensuring the agent receives the full Virtual Assistant (VA) summary.</p>"},{"location":"overview/#lab-4-ai-assisted-human-rt-assist","title":"Lab 4: AI Assisted Human (RT Assist)","text":"<p>Enable RT Assist to provide live guidance, automate card-locking in the backend, and generate automatic call wrap-ups.</p>"},{"location":"overview/#getting-started-partner-tenant-pre-requisites","title":"Getting Started: Partner Tenant Pre-requisites","text":"<p>To participate in the labs, ensure you have access to the following resources:</p> <ul> <li>Your Partner tenant (Gold Tenant or NFR Demo/Lab)</li> <li>Your Control Hub Portal </li> <li>Your Campaign Management portal</li> </ul> <p>Furthermore, you will need the following features enabled in your tenant: </p> <pre><code>\u2705 AI Agent\n\u2705 AI Assistant\n\u2705 Cisco Campaign Manager\n</code></pre> <p>For the purpose of the use case, additional tools are required throughout the labs: </p> <ol> <li>Airtable: you will use Airtable to generate customer data that simulates a customer CRM or DB</li> <li>Novapay Payment Service: you will get access to a Cisco Mock Payment service for the purpose of the Bootcamp. You will find instructions on how to replicate this Mock payment service for your demos, although this will not be part of the Bootcamp content.</li> </ol>"},{"location":"overview/#disclaimer","title":"Disclaimer","text":"<ul> <li>All use cases and data presented in this Bootcamp are fictional and do not correspond to any real customer or user.</li> <li>The availability of the NovaPay Payment Service is guaranteed for the duration of the Bootcamp only. Any use of the service for demonstrations outside the scope of the Bootcamp labs is the responsibility of the partner, and Cisco does not guarantee the continued availability or maintenance of the service in such cases.</li> <li>While the lab design and configuration examples may be used as reference material, for any design-related questions please contact your Cisco representative or an authorized Cisco partner.</li> </ul>"},{"location":"topologies/","title":"Lab topologies","text":""},{"location":"topologies/#lab-topologies","title":"Lab topologies","text":""},{"location":"howToUse/admonition/","title":"Admonition","text":"<p>In addition to the  stock admonitions which are available out of the box we have added some additional branded admonitions which were created by Bobby McGonigle. </p> <p>Blank</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <pre><code>console.log('Hello Blank!')\n</code></pre> <p>Vidcast</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <pre><code>console.log('Hello Vidcast!')\n</code></pre> <p>Download</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <pre><code>console.log('Hello Download!')\n</code></pre> <p>Cedeploy</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <pre><code>console.log('Hello Ce-Deploy!')\n</code></pre> <p>Webex</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <pre><code>console.log('Hello Webex!')\n</code></pre> <p>Gif</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <pre><code>console.log('How should I pronounce Gif?')\n</code></pre> <p>Important</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <pre><code>console.log('Hello Important!')\n</code></pre> <p>Challenge</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <pre><code>console.log('Hello Challenge!')\n</code></pre> <p>Tool</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <pre><code>console.log('Hello Tool!')\n</code></pre> <p>Curious</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <pre><code>console.log('Hello Curious!')\n</code></pre>"},{"location":"howToUse/customFeatures/","title":"customFeatures","text":""},{"location":"howToUse/customFeatures/#adding-a-copy-button-without-a-code-block","title":"Adding a Copy Button Without a Code Block","text":"<p><code>This will copy the following text: &lt;copy&gt;Text to copy&lt;/copy&gt;</code> </p> <p>This will copy the following text: Text to copy</p>"},{"location":"howToUse/customFeatures/#adding-user-specific-variables-into-your-lab-guide","title":"Adding user specific variables into your lab guide","text":"<p>There may be times in which you want to embed some attendee specific information into the instructions of your lab guide, like credentials or phone numbers, which will be used on multiple pages of your lab guide.  You can gather the information via a form or you can pass a pre-encoded JSON string as a URL parameter to populate the variable values into the browser's session storage.  Then you can use a simple HTML tag with a special class name to update the values in the lab guide.  This feature can be combined with the copy button method above.</p>"},{"location":"howToUse/customFeatures/#form-method","title":"Form Method","text":"Show me the code <pre><code>&lt;form id=\"info\"&gt;\n\n\n&lt;label for=\"Admin\"&gt;Admin Login:&lt;/label&gt;\n&lt;input type=\"text\" id=\"Admin\" name=\"Admin\"&gt;&lt;br&gt;\n\n&lt;label for=\"PW\"&gt;Admin Password:&lt;/label&gt;\n&lt;input type=\"text\" id=\"PW\" name=\"PW\"&gt;&lt;br&gt;\n\n&lt;label for=\"EP\"&gt;Inbound Channel Name:&lt;/label&gt;\n&lt;input type=\"text\" id=\"EP\" name=\"EP\"&gt;&lt;br&gt;\n\n&lt;label for=\"DN\"&gt;Inbound Channel Phone Number:&lt;/label&gt;\n&lt;input type=\"text\" id=\"DN\" name=\"DN\"&gt;&lt;br&gt;\n\n&lt;label for=\"Queue\"&gt;Queue 1 Name:&lt;/label&gt;\n&lt;input type=\"text\" id=\"Queue\" name=\"Queue\"&gt;&lt;br&gt;\n\n&lt;label for=\"Queue2\"&gt;Queue 2 Name:&lt;/label&gt;\n&lt;input type=\"text\" id=\"Queue2\" name=\"Queue2\"&gt;&lt;br&gt;\n\n&lt;label for=\"Team\"&gt;Team 1 Name:&lt;/label&gt;\n&lt;input type=\"text\" id=\"Team\" name=\"Team\"&gt;&lt;br&gt;\n\n&lt;label for=\"Team2\"&gt;Team 2 Name:&lt;/label&gt;\n&lt;input type=\"text\" id=\"Team2\" name=\"Team2\"&gt;&lt;br&gt;\n&lt;br&gt;\n&lt;button onclick=\"setValues()\"&gt;Update Lab Guide&lt;/button&gt;\n&lt;/form&gt;\n</code></pre> Example Input Form Admin Login: Admin Password: Inbound Channel Name: Inbound Channel Phone Number: Queue 1 Name: Queue 2 Name: Team 1 Name: Team 2 Name: Update Lab Guide <p>Login: Provided by proctor</p> <p>Password: Provided by proctor</p> <p>Assigned Inbound Channel Name: Provided by proctor</p> <p>Assigned Inbound Channel Number: Provided by proctor</p> <p>Assigned Queue Name 1: Provided by proctor</p> <p>Assigned Queue Name 2: Provided by proctor</p> <p>Assigned Team name 1: Provided by proctor</p> <p>Assigned Team name 2: Provided by proctor</p>"},{"location":"howToUse/customFeatures/#url-method","title":"URL Method","text":"<p>If you have a lot of attendee variables in your lab, you may choose to precompile and encode them so that you can simply provide a URL link which will load all of their required information.</p> <p>To see this in action, add this string at the end of the URL for any page on this site: ?eyJBZG1pbiI6ImFkbWluQHh5ei5iaXoiLCJQVyI6InNVcGVyU2VjcmV0MTIzISIsIkVQIjoiRVAxIiwiRE4iOiIrMTkxMDU1NTEyMTUyIiwiUXVldWUiOiJRdWV1ZTEiLCJRdWV1ZTIiOiJRdWV1ZTIiLCJUZWFtIjoiVGVhbTEiLCJUZWFtMiI6IlRlYW0yIn0=</p>"},{"location":"howToUse/initialSetup/","title":"Initial Setup","text":""},{"location":"howToUse/initialSetup/#initial-setup","title":"Initial Setup","text":"<p>This lab guide template uses MKDocs to take your markdown documentation and transform it into an interactive web based lab guide.  You will need to install some software on your PC or Mac in order to take full advantage of the tool which will allow you to view your changes as you save them and ensure that your formatting is exactly how you want it.</p>"},{"location":"howToUse/initialSetup/#prerequisite-software-to-install","title":"Prerequisite Software to Install","text":"<ol> <li>Python</li> <li>Visual Studio Code</li> <li>Git</li> </ol>"},{"location":"howToUse/initialSetup/#setting-up-your-lab-guide-on-your-computer","title":"Setting up your lab guide on your computer","text":""},{"location":"howToUse/initialSetup/#clone-your-repository-with-git","title":"Clone your repository with git","text":"<p>Open Visual Studio Code</p> <p>Click the Source Control button in the left menu </p> <p>Click Clone Repository</p> <p>Enter the repository source:  {{config.extra.repo}}</p> <p>Select or create a new folder to clone the repository into.</p>"},{"location":"howToUse/initialSetup/#build-the-environment","title":"Build the environment","text":"<p>When prompted to open the cloned repository, select open.</p> <p>Drag open the terminal at the bottom of the Visual Studio Code window</p> Show Me <p></p> If you are on a PCIf you are on a Mac <p>In your terminal enter the following commands:</p> <p>python -m venv venv</p> <p>Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser</p> <p>venv\\Scripts\\activate.ps1</p> <p>pip install -r requirements.txt</p> <p>mkdocs serve</p> <p>Open a browser to http://127.0.0.1:8000 </p> <p>In your terminal enter the following commands:</p> <p>python -m venv venv</p> <p>source venv/bin/activate</p> <p>pip install -r requirements.txt</p> <p>mkdocs serve</p> <p>Open a browser to http://127.0.0.1:8000</p>"},{"location":"howToUse/postInitial/","title":"Using the tool after the initial setup","text":""},{"location":"howToUse/postInitial/#using-the-tool-after-the-initial-setup","title":"Using the tool after the initial setup","text":"<p>After the initial setup you will only need to take the following steps:</p> <p>Open Visual Studio Code</p> <p>Click the Source Control button in the left menu </p> <p>Click Open Folder and navigate to the folder where you cloned the repository</p> If you are on a PCIf you are on a Mac <p>In your terminal enter the following commands:</p> <p>venv\\Scripts\\activate.ps1</p> <p>mkdocs serve</p> <p>Open a browser to http://127.0.0.1:8000</p> <p>In your terminal enter the following commands:</p> <p>source venv/bin/activate</p> <p>mkdocs serve</p> <p>Open a browser to http://127.0.0.1:8000</p>"},{"location":"howToUse/references/","title":"References","text":""},{"location":"howToUse/references/#mk-docs-feature-reference","title":"MK Docs Feature Reference:","text":"<p>https://squidfunk.github.io/mkdocs-material/reference/ </p>"},{"location":"howToUse/references/#markdown-cheat-sheets","title":"Markdown Cheat Sheets:","text":"<p>https://www.markdownguide.org/cheat-sheet/ </p> <p>https://github.com/lifeparticle/Markdown-Cheatsheet </p>"},{"location":"howToUse/syncChanges/","title":"Publishing Your Changes","text":""},{"location":"howToUse/syncChanges/#publishing-your-changes","title":"Publishing Your Changes","text":"<p>As you progress with the creation of your lab guide, you should sync your changes periodically to GitHub.  </p>"},{"location":"howToUse/syncChanges/#syncing-your-changes-to-github","title":"Syncing your changes to GitHub","text":"<p>Make sure that you have saved all of the files you want to sync up to the repository</p> <p>Click the Source Control button in the left menu </p> <p>Click the plus sign next to each file you want to sync as you hover over the file names or alternatively, click the plus sign next to changes</p> <p>Enter a note about the changes you are making in the message text box</p> <p>Click the down chevron  on the commit button to reveal more options</p> <p>Select Commit &amp; Sync </p>"},{"location":"howToUse/syncChanges/#after-you-sync-your-changes-it-will-take-a-few-minutes-for-github-actions-to-build-the-website-so-that-you-can-view-all-of-the-changes-you-made","title":"After you Sync your changes, it will take a few minutes for GitHub Actions to build the website so that you can view all of the changes you made.","text":""}]}